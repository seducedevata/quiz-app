#!/usr/bin/env python3
"""
ðŸš€ BUG FIX 26: Quiz Service Layer

This service layer decouples the PythonBridge from direct thread management,
implementing proper service-oriented architecture where the bridge is just
a simple communication layer.
"""

import logging
from typing import Dict, Any, Optional
from PyQt5.QtCore import QObject, pyqtSignal, QThread

logger = logging.getLogger(__name__)

class QuizService(QObject):
    """
    ðŸš€ BUG FIX 26: Dedicated service for quiz generation business logic
    
    This service encapsulates all quiz generation logic and thread management,
    allowing the PythonBridge to be a simple pass-through communication layer.
    """
    
    # Signals for communicating with the UI layer
    questionGenerated = pyqtSignal('QVariant')
    batchCompleted = pyqtSignal(int)
    generationStarted = pyqtSignal(str)  # Status message
    generationFailed = pyqtSignal(str)   # Error message
    
    def __init__(self, mcq_manager=None):
        super().__init__()
        self.mcq_manager = mcq_manager
        self.current_generator = None
        self.generation_active = False
        
        logger.info("âœ… QuizService initialized")
    
    def is_generation_active(self) -> bool:
        """Check if question generation is currently active"""
        return (self.current_generator is not None and 
                self.current_generator.isRunning())
    
    def start_question_generation(self, quiz_params: Dict[str, Any], num_questions: int = 1):
        """
        Start question generation with the given parameters
        
        Args:
            quiz_params: Quiz parameters (topic, difficulty, etc.)
            num_questions: Number of questions to generate
        """
        try:
            # Check if generation is already active
            if self.is_generation_active():
                logger.warning("Question generation already in progress")
                self.generationFailed.emit("Question generation already in progress. Please wait.")
                return
            
            # Validate MCQ manager
            if not self.mcq_manager:
                logger.error("MCQ manager not available")
                self.generationFailed.emit("Question generation service not available")
                return
            
            # Import here to avoid circular imports
            from knowledge_app.webengine_app import FastQuestionGenerator
            
            # Create new generator
            self.current_generator = FastQuestionGenerator(
                self.mcq_manager, 
                quiz_params, 
                num_questions
            )
            
            # Connect signals
            self.current_generator.questionGenerated.connect(self._on_question_generated)
            self.current_generator.batchCompleted.connect(self._on_batch_completed)
            
            # Start generation
            self.generation_active = True
            self.current_generator.start()
            
            topic = quiz_params.get('topic', 'Unknown')
            difficulty = quiz_params.get('difficulty', 'medium')
            self.generationStarted.emit(f"Generating {num_questions} question(s) about {topic} ({difficulty})")
            
            logger.info(f"âœ… Question generation started: {topic} ({difficulty})")
            
        except Exception as e:
            logger.error(f"âŒ Failed to start question generation: {e}")
            self.generation_active = False
            self.generationFailed.emit(f"Failed to start question generation: {str(e)}")
    
    def stop_question_generation(self):
        """Stop current question generation"""
        try:
            if self.current_generator and self.current_generator.isRunning():
                logger.info("ðŸ›‘ Stopping question generation...")
                self.current_generator.stop()
                
                # Wait for graceful shutdown
                if not self.current_generator.wait(3000):  # 3 second timeout
                    logger.warning("âš ï¸ Generator did not stop gracefully")
                
                self.current_generator = None
                self.generation_active = False
                logger.info("âœ… Question generation stopped")
            else:
                logger.warning("No active question generation to stop")
                
        except Exception as e:
            logger.error(f"âŒ Error stopping question generation: {e}")
    
    def _on_question_generated(self, question_data):
        """Handle question generated signal from worker thread"""
        try:
            logger.debug("âœ… Question generated by service")
            self.questionGenerated.emit(question_data)
        except Exception as e:
            logger.error(f"âŒ Error handling generated question: {e}")
    
    def _on_batch_completed(self, count):
        """Handle batch completion signal from worker thread"""
        try:
            logger.info(f"âœ… Batch generation completed: {count} questions")
            self.generation_active = False
            self.current_generator = None
            self.batchCompleted.emit(count)
        except Exception as e:
            logger.error(f"âŒ Error handling batch completion: {e}")
    
    def cleanup(self):
        """Clean up service resources"""
        try:
            self.stop_question_generation()
            logger.info("âœ… QuizService cleanup complete")
        except Exception as e:
            logger.error(f"âŒ Error during QuizService cleanup: {e}")


class TrainingService(QObject):
    """
    ðŸš€ BUG FIX 26: Dedicated service for training business logic
    
    This service encapsulates all training logic and thread management,
    allowing the PythonBridge to be a simple pass-through communication layer.
    """
    
    # Signals for communicating with the UI layer
    trainingProgress = pyqtSignal(str)
    trainingCompleted = pyqtSignal(str)
    trainingError = pyqtSignal(str)
    trainingStarted = pyqtSignal(str)
    
    def __init__(self, training_manager=None):
        super().__init__()
        self.training_manager = training_manager
        self.current_training_thread = None
        self.training_active = False
        
        logger.info("âœ… TrainingService initialized")
    
    def is_training_active(self) -> bool:
        """Check if training is currently active"""
        return (self.current_training_thread is not None and 
                self.current_training_thread.isRunning())
    
    def start_training(self, dataset_path: str, epochs: int, learning_rate: float):
        """
        Start training with the given parameters
        
        Args:
            dataset_path: Path to training dataset
            epochs: Number of training epochs
            learning_rate: Learning rate for training
        """
        try:
            # Check if training is already active
            if self.is_training_active():
                logger.warning("Training already in progress")
                self.trainingError.emit("Training already in progress. Please wait.")
                return
            
            # Validate training manager
            if not self.training_manager:
                logger.error("Training manager not available")
                self.trainingError.emit("Training manager not available")
                return
            
            # Import here to avoid circular imports
            from knowledge_app.webengine_app import TrainingThread
            
            # Create new training thread
            self.current_training_thread = TrainingThread(
                self.training_manager,
                dataset_path,
                epochs,
                learning_rate
            )
            
            # Connect signals
            self.current_training_thread.progress.connect(self._on_training_progress)
            self.current_training_thread.completed.connect(self._on_training_completed)
            self.current_training_thread.error.connect(self._on_training_error)
            
            # Start training
            self.training_active = True
            self.current_training_thread.start()
            
            self.trainingStarted.emit(f"Training started: {epochs} epochs, LR: {learning_rate}")
            logger.info(f"âœ… Training started: {dataset_path}, {epochs} epochs, LR: {learning_rate}")
            
        except Exception as e:
            logger.error(f"âŒ Failed to start training: {e}")
            self.training_active = False
            self.trainingError.emit(f"Failed to start training: {str(e)}")
    
    def stop_training(self):
        """Stop current training"""
        try:
            if self.current_training_thread and self.current_training_thread.isRunning():
                logger.info("ðŸ›‘ Stopping training...")
                self.current_training_thread.stop()
                self.trainingProgress.emit("Stopping training...")
                
                # Wait for graceful shutdown
                if not self.current_training_thread.wait(5000):  # 5 second timeout
                    logger.warning("âš ï¸ Training thread did not stop gracefully")
                
                self.current_training_thread = None
                self.training_active = False
                logger.info("âœ… Training stopped")
            else:
                logger.warning("No active training to stop")
                self.trainingError.emit("No training in progress to stop")
                
        except Exception as e:
            logger.error(f"âŒ Error stopping training: {e}")
            self.trainingError.emit(f"Error stopping training: {str(e)}")
    
    def _on_training_progress(self, message):
        """Handle training progress signal from worker thread"""
        try:
            logger.debug(f"ðŸ“Š Training progress: {message}")
            self.trainingProgress.emit(message)
        except Exception as e:
            logger.error(f"âŒ Error handling training progress: {e}")
    
    def _on_training_completed(self, message):
        """Handle training completion signal from worker thread"""
        try:
            logger.info(f"âœ… Training completed: {message}")
            self.training_active = False
            self.current_training_thread = None
            self.trainingCompleted.emit(message)
        except Exception as e:
            logger.error(f"âŒ Error handling training completion: {e}")
    
    def _on_training_error(self, message):
        """Handle training error signal from worker thread"""
        try:
            logger.error(f"âŒ Training error: {message}")
            self.training_active = False
            self.current_training_thread = None
            self.trainingError.emit(message)
        except Exception as e:
            logger.error(f"âŒ Error handling training error: {e}")
    
    def cleanup(self):
        """Clean up service resources"""
        try:
            self.stop_training()
            logger.info("âœ… TrainingService cleanup complete")
        except Exception as e:
            logger.error(f"âŒ Error during TrainingService cleanup: {e}")


# Global service instances
_quiz_service = None
_training_service = None

def get_quiz_service(mcq_manager=None) -> QuizService:
    """Get the global quiz service instance"""
    global _quiz_service
    if _quiz_service is None:
        _quiz_service = QuizService(mcq_manager)
    return _quiz_service

def get_training_service(training_manager=None) -> TrainingService:
    """Get the global training service instance"""
    global _training_service
    if _training_service is None:
        _training_service = TrainingService(training_manager)
    return _training_service
